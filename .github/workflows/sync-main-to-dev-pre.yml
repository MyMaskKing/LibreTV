name: 同步main到dev测试分支(Beta版)

on:
  # 只允许手动触发
  workflow_dispatch:

# 添加必要的权限
permissions:
  contents: write
  issues: write
  pull-requests: write

env:
  BACKUP_DIR: '.sync-backups'
  TEMP_DIR: '.sync-temp'
  BACKUP_RETAIN_DAYS: 7
  # 排除文件配置文件路径
  EXCLUDE_FILES_CONFIG: 'sync-exclude.txt'

jobs:
  sync-branches:
    runs-on: ubuntu-latest
    
    steps:
      - name: 检出代码
        uses: actions/checkout@v3
        with:
          fetch-depth: 0
          token: ${{ secrets.GITHUB_TOKEN }}
      
      - name: 配置Git
        run: |
          git config --global user.name 'GitHub Actions'
          git config --global user.email 'github-actions[bot]@users.noreply.github.com'
          echo "✅ Git配置完成"
      
      - name: 读取排除文件列表并备份
        id: backup
        run: |
          if [ ! -f "$EXCLUDE_FILES_CONFIG" ]; then
            echo "❌ 错误：排除文件配置 $EXCLUDE_FILES_CONFIG 不存在"
            exit 1
          fi
          mkdir -p "$TEMP_DIR"
          cp "$EXCLUDE_FILES_CONFIG" "$TEMP_DIR/exclude_config.bak"
          EXCLUDE_PATTERNS=()
          while IFS= read -r line || [[ -n "$line" ]]; do
            if [[ -z "$line" || "$line" =~ ^[[:space:]]*# ]]; then
              continue
            fi
            line=$(echo "$line" | xargs)
            if [[ -n "$line" ]]; then
              EXCLUDE_PATTERNS+=("$line")
              echo "  - 排除: $line"
            fi
          done < "$EXCLUDE_FILES_CONFIG"
          for pattern in "${EXCLUDE_PATTERNS[@]}"; do
            if [[ "$pattern" == */ ]]; then
              mkdir -p "$TEMP_DIR/$pattern"
              cp -r "$pattern"* "$TEMP_DIR/$pattern" 2>/dev/null || true
            else
              target_dir="$TEMP_DIR/$(dirname "$pattern")"
              mkdir -p "$target_dir"
              cp -r $pattern "$target_dir/" 2>/dev/null || true
            fi
          done

      - name: 合并main分支到custom-dev
        id: merge
        run: |
          git fetch origin
          git fetch origin main:main
          if ! git show-ref --verify --quiet refs/remotes/origin/custom-dev; then
            git checkout -b custom-dev
          else
            git checkout custom-dev
            git reset --hard origin/custom-dev
          fi
          git merge --abort || true
          if git merge origin/main --no-commit; then
            echo "MERGE_CONFLICT=false" >> $GITHUB_ENV
          else
            echo "MERGE_CONFLICT=true" >> $GITHUB_ENV
          fi

      - name: 检查并处理合并冲突
        if: env.MERGE_CONFLICT == 'true'
        id: handle_conflict
        run: |
          CONFLICT_FILES=$(git status --porcelain | grep "^UU" | cut -c4-)
          if [ -z "$CONFLICT_FILES" ]; then
            echo "❌ 没有检测到冲突文件，可能是其他错误"
            git status
            exit 1
          fi
          FILTERED_CONFLICT_FILES=""
          while IFS= read -r file; do
            if [[ ! "$file" =~ ^\.github/workflows/ ]]; then
              FILTERED_CONFLICT_FILES="${FILTERED_CONFLICT_FILES}${file}\n"
            fi
          done <<< "$CONFLICT_FILES"
          FILTERED_CONFLICT_FILES=$(echo -e "$FILTERED_CONFLICT_FILES" | sed '$ s/\\n$//')
          echo "CONFLICT_FILES<<EOF" >> $GITHUB_ENV
          echo -e "$FILTERED_CONFLICT_FILES" >> $GITHUB_ENV
          echo "EOF" >> $GITHUB_ENV
          BACKUP_FILES=""
          REPO_ROOT=$(pwd)
          BACKUP_ROOT="../backup_files"
          rm -rf "$BACKUP_ROOT"
          mkdir -p "$BACKUP_ROOT"
          while IFS= read -r file; do
            if [ -z "$file" ]; then
              continue
            fi
            if [ ! -f "$file" ]; then
              continue
            fi
            file_dir=$(dirname "$file")
            backup_dir="$BACKUP_ROOT/$file_dir"
            mkdir -p "$backup_dir"
            backup_name="$(basename "$file").$(date +%Y%m%d_%H%M%S).backup"
            backup_file="$backup_dir/$backup_name"
            cp "$file" "$backup_file" || true
            if [ -f "$backup_file" ]; then
              BACKUP_FILES="${BACKUP_FILES}\n$backup_file"
              git checkout origin/main -- "$file"
              git add "$file"
            fi
          done <<< "$FILTERED_CONFLICT_FILES"
          git reset --hard HEAD
          git clean -f -d
          git checkout origin/main -- .
          rm -rf .github/workflows/*
          git checkout custom-dev -- .github/workflows/
          if [ -d "$BACKUP_ROOT" ]; then
            cp -r "$BACKUP_ROOT"/* .
            rm -rf "$BACKUP_ROOT"
          fi
          git add -A
          git commit -m "同步main分支代码，并保存冲突文件备份" || echo "没有需要提交的更改"
          git push --force origin custom-dev
          echo "BACKUP_FILES<<EOF" >> $GITHUB_ENV
          echo -e "$BACKUP_FILES" >> $GITHUB_ENV
          echo "EOF" >> $GITHUB_ENV

      - name: 创建Issue报告
        if: env.MERGE_CONFLICT == 'true'
        uses: actions/github-script@v6
        with:
          script: |
            const issueBody = `
            # main -> custom-dev 同步冲突报告
            
            在同步过程中发现以下文件存在冲突，已自动使用main分支的代码并备份原文件。
            
            ## 冲突文件列表
            \n\n\`\`\`
            ${process.env.CONFLICT_FILES}
            \`\`\`
            
            ## 备份文件
            已在每个冲突文件的同目录下创建备份文件：
            \n\n\`\`\`
            ${process.env.BACKUP_FILES}
            \`\`\`
            
            ## 处理说明
            1. 所有冲突文件已使用main分支的版本
            2. custom-dev分支的原始代码已在同目录下备份
            3. 如需恢复或合并自定义代码，请参考备份文件
            
            ## 手动处理步骤
            1. 检查备份文件内容
            2. 如需修改，请在custom-dev分支上进行更改
            3. 确保更改后的代码与main分支的改动不冲突
            `;
            await github.rest.issues.create({
              owner: context.repo.owner,
              repo: context.repo.repo,
              title: '🔄 main -> custom-dev 同步冲突报告',
              body: issueBody,
              labels: ['sync-conflict']
            });

      - name: 恢复自定义文件并提交
        if: env.MERGE_CONFLICT == 'false'
        run: |
          cp "$TEMP_DIR/exclude_config.bak" "$EXCLUDE_FILES_CONFIG"
          EXCLUDE_PATTERNS=()
          while IFS= read -r line || [[ -n "$line" ]]; do
            if [[ -z "$line" || "$line" =~ ^[[:space:]]*# ]]; then
              continue
            fi
            line=$(echo "$line" | xargs)
            if [[ -n "$line" ]]; then
              EXCLUDE_PATTERNS+=("$line")
            fi
          done < "$EXCLUDE_FILES_CONFIG"
          RESTORED_COUNT=0
          for pattern in "${EXCLUDE_PATTERNS[@]}"; do
            if [[ "$pattern" == */ ]]; then
              backup_dir="$TEMP_DIR/$pattern"
              if [ -d "$backup_dir" ]; then
                find "$backup_dir" -type f | while read backup_file; do
                  rel_path=${backup_file#"$TEMP_DIR/"}
                  target_dir=$(dirname "$rel_path")
                  mkdir -p "$target_dir"
                  cp "$backup_file" "$rel_path"
                  RESTORED_COUNT=$((RESTORED_COUNT + 1))
                done
              fi
            else
              backup_pattern="$TEMP_DIR/$pattern"
              shopt -s nullglob
              backup_files=($backup_pattern)
              shopt -u nullglob
              for backup_file in "${backup_files[@]}"; do
                if [ -f "$backup_file" ]; then
                  rel_path=${backup_file#"$TEMP_DIR/"}
                  target_dir=$(dirname "$rel_path")
                  mkdir -p "$target_dir"
                  cp "$backup_file" "$rel_path"
                  RESTORED_COUNT=$((RESTORED_COUNT + 1))
                fi
              done
            fi
          done
          git add -A
          if git diff --cached --quiet; then
            echo "✅ 没有需要提交的更改，同步完成"
          else
            git commit -m "同步main分支代码，保留custom-dev分支的自定义修改"
            git push origin custom-dev
            echo "✅ 同步完成"
          fi

      - name: 清理临时文件
        if: always()
        run: |
          rm -rf $TEMP_DIR
          echo "🧹 清理临时文件完成"
      
      - name: 通知结果
        run: |
          echo "✅ 智能同步流程已完成。custom-dev 分支现在包含 main 分支的代码，并保留了排除列表中指定的自定义修改。" 
