name: 同步main到dev测试分支(Beta版)

on:
  # 只允许手动触发
  workflow_dispatch:

# 添加必要的权限
permissions:
  contents: write
  issues: write
  pull-requests: write

env:
  BACKUP_DIR: '.sync-backups'
  TEMP_DIR: '.sync-temp'
  BACKUP_RETAIN_DAYS: 7
  # 排除文件配置文件路径
  EXCLUDE_FILES_CONFIG: 'sync-exclude.txt'

jobs:
  sync-branches:
    runs-on: ubuntu-latest
    
    steps:
      - name: 检出代码
        uses: actions/checkout@v3
        with:
          fetch-depth: 0
          token: ${{ secrets.GITHUB_TOKEN }}
      
      - name: 配置Git
        run: |
          git config --global user.name 'GitHub Actions'
          git config --global user.email 'github-actions[bot]@users.noreply.github.com'
          echo "✅ Git配置完成"
      
      - name: 智能同步main分支到custom-dev
        run: |
          echo "🚀 开始智能同步main分支到custom-dev分支..."
          
          echo "📥 获取最新代码..."
          git fetch origin
          git fetch origin main:main
          
          echo "🔍 检查custom-dev分支状态..."
          if ! git show-ref --verify --quiet refs/remotes/origin/custom-dev; then
            echo "⚠️ custom-dev分支不存在，正在创建..."
            git checkout -b custom-dev
            echo "✅ custom-dev分支创建成功"
          else
            echo "✅ 切换到已存在的custom-dev分支"
            git checkout custom-dev
            echo "🔄 重置分支到最新状态"
            git reset --hard origin/custom-dev
          fi

          # 检查排除文件配置是否存在
          if [ ! -f "$EXCLUDE_FILES_CONFIG" ]; then
            echo "❌ 错误：排除文件配置 $EXCLUDE_FILES_CONFIG 不存在"
            echo "请先在 custom-dev 分支创建配置文件，定义需要保留的自定义修改"
            echo "配置文件格式示例："
            echo "# 这个文件定义了哪些文件应该保留custom-dev分支的修改"
            echo "# 每行一个文件或目录路径，支持通配符"
            echo "# 以#开头的行为注释"
            echo ""
            echo ".github/workflows/"
            echo "js/sync/sync.js"
            echo "player.html"
            echo "$EXCLUDE_FILES_CONFIG"
            exit 1
          fi

          # 保存配置文件
          echo "💾 保存配置文件..."
          mkdir -p "$TEMP_DIR"
          cp "$EXCLUDE_FILES_CONFIG" "$TEMP_DIR/exclude_config.bak"

          # 读取排除文件列表
          echo "📋 读取排除文件列表..."
          EXCLUDE_PATTERNS=()
          while IFS= read -r line || [[ -n "$line" ]]; do
            # 跳过空行和注释
            if [[ -z "$line" || "$line" =~ ^[[:space:]]*# ]]; then
              continue
            fi
            # 去除前后空格
            line=$(echo "$line" | xargs)
            if [[ -n "$line" ]]; then
              EXCLUDE_PATTERNS+=("$line")
              echo "  - 排除: $line"
            fi
          done < "$EXCLUDE_FILES_CONFIG"

          # 创建临时目录存储差异
          REPO_ROOT=$(pwd)
          DIFF_DIR="${REPO_ROOT}/$TEMP_DIR/diff-patches"
          rm -rf "$DIFF_DIR"
          mkdir -p "$DIFF_DIR"

          # 为每个排除文件创建差异补丁
          echo "🔍 为排除文件生成差异补丁..."
          for pattern in "${EXCLUDE_PATTERNS[@]}"; do
            # 处理目录模式（以/结尾）
            if [[ "$pattern" == */ ]]; then
              echo "📄 处理目录: $pattern"
              # 获取目录下所有文件
              files=$(find "$pattern" -type f 2>/dev/null || echo "")
              for file in $files; do
                if [ -f "$file" ]; then
                  # 为每个文件创建差异补丁
                  patch_file="${DIFF_DIR}/${file//\//_}.patch"
                  echo "  - 为文件创建补丁: $file"
                  git diff main custom-dev -- "$file" > "$patch_file"
                fi
              done
            # 处理具体文件或通配符
            else
              # 改进通配符模式的文件匹配
              files=$(find . -path "./$pattern" -o -path "$pattern" 2>/dev/null || echo "")
              if [ -z "$files" ]; then
                # 尝试使用通配符展开
                shopt -s nullglob
                files=($pattern)
                shopt -u nullglob
              fi
              
              for file in $files; do
                if [ -f "$file" ]; then
                  patch_file="${DIFF_DIR}/${file//\//_}.patch"
                  echo "📄 为文件创建补丁: $file"
                  git diff main custom-dev -- "$file" > "$patch_file"
                fi
              done
            fi
          done

          # 创建临时分支（基于main）
          echo "🔄 创建临时分支（基于main）..."
          git checkout main
          git checkout -b temp-sync-branch
          
          # 恢复配置文件
          echo "🔄 恢复配置文件..."
          mkdir -p $(dirname "$EXCLUDE_FILES_CONFIG")
          cp "$TEMP_DIR/exclude_config.bak" "$EXCLUDE_FILES_CONFIG"

          # 应用差异补丁
          echo "🔄 应用custom-dev分支的修改..."
          PATCH_COUNT=0
          REJECT_COUNT=0
          
          # 检查补丁目录是否存在补丁文件
          if [ -d "$DIFF_DIR" ] && [ "$(ls -A "$DIFF_DIR" 2>/dev/null)" ]; then
            for patch_file in "$DIFF_DIR"/*.patch; do
              if [ -s "$patch_file" ]; then  # 只处理非空补丁文件
                # 从补丁文件名恢复原始文件路径
                original_file=$(basename "$patch_file" .patch | tr '_' '/')
                
                echo "📄 应用补丁到文件: $original_file"
                PATCH_COUNT=$((PATCH_COUNT + 1))
                
                # 创建目录（如果需要）
                mkdir -p "$(dirname "$original_file")" 2>/dev/null || true
                
                # 应用补丁
                if ! git apply --ignore-whitespace --reject "$patch_file" 2>/dev/null; then
                  echo "⚠️ 补丁应用失败，尝试使用宽松模式..."
                  if ! git apply --ignore-whitespace --reject --ignore-space-change --3way "$patch_file" 2>/dev/null; then
                    echo "❌ 无法应用补丁到: $original_file"
                    REJECT_COUNT=$((REJECT_COUNT + 1))
                  fi
                fi
              fi
            done
          else
            echo "ℹ️ 没有找到需要应用的补丁文件"
          fi
          
          # 检查是否有拒绝的补丁
          REJECT_FILES=$(find . -name "*.rej")
          if [ -n "$REJECT_FILES" ]; then
            echo "⚠️ 警告：以下文件的补丁应用失败："
            echo "$REJECT_FILES"
            echo "请手动检查这些文件"
          fi
          
          echo "📊 补丁统计: 应用 $PATCH_COUNT 个补丁，$REJECT_COUNT 个失败"

          # 清理差异目录
          rm -rf "$DIFF_DIR"
          
          # 提交更改
          echo "📝 提交更改..."
          git add -A
          
          # 检查是否有更改需要提交
          if git diff --cached --quiet; then
            echo "✅ 没有需要提交的更改，同步完成"
          else
            git commit -m "同步main分支代码，保留custom-dev分支的自定义修改"
            
            echo "🚀 推送到custom-dev分支..."
            git push --force origin temp-sync-branch:custom-dev
            
            echo "✅ 同步完成"
          fi

      - name: 清理临时文件
        if: always()
        run: |
          rm -rf $TEMP_DIR
          echo "🧹 清理临时文件完成"
      
      - name: 通知结果
        run: |
          echo "✅ 智能同步流程已完成。custom-dev 分支现在包含 main 分支的代码，并保留了排除列表中指定的自定义修改。" 
